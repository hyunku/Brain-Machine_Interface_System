import numpy as np
from numpy import arange, array, concatenate, ones, tanh, vstack, zeros

import scipy.linalg as la

from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.utils import check_array, check_random_state


class SimpleESN(BaseEstimator, TransformerMixin):

    # ESN 모델 설정 가능 파라미터
    def __init__(self, n_readout, n_components=10000, damping=0.2,
                 weight_scaling=1.25, discard_steps=0, random_state=None):
        self.n_readout = n_readout  # 출력층 뉴런 수
        self.n_components = n_components  # reservoir 뉴런 수
        self.damping = damping  # reservoir 내 뉴런 손실률(뉴런끼리 연결 안될 확률)
        self.weight_scaling = weight_scaling  # 가중치 학습률
        self.discard_steps = discard_steps  # dropout(데이터 버릴확률)
        self.random_state = check_random_state(random_state)
        self.input_weights_ = None
        self.readout_idx_ = None
        self.weights_ = None

    # ESN 모델 학습 (현재 캡슐화 상태 -> 건드리지 말라고 권장한다는 의미.)
    def _fit_transform(self, X):
        n_samples, n_features = X.shape

        X = check_array(X, ensure_2d=True)

        self.weights_ = self.random_state.rand(
            self.n_components, self.n_components) - 0.5

        # spectral_radius = np.max(np.abs(la.eig(self.weights_)[0]))   # 기본값
        spectral_radius = 0.1

        self.weights_ *= self.weight_scaling / spectral_radius

        self.input_weights_ = self.random_state.rand(self.n_components,
                                                     1 + n_features) - 0.5
        self.readout_idx_ = self.random_state.permutation(
            arange(1 + n_features,
                   1 + n_features + self.n_components))[:self.n_readout]
        self.components_ = zeros(shape=(1 + n_features + self.n_components,
                                        n_samples))

        curr_ = zeros(shape=(self.n_components, 1))
        U = concatenate((ones(shape=(n_samples, 1)), X), axis=1)
        for t in range(n_samples):
            u = array(U[t, :], ndmin=2).T
            curr_ = (1 - self.damping) * curr_ + self.damping * tanh(
                self.input_weights_.dot(u) + self.weights_.dot(curr_))
            self.components_[:, t] = vstack((u, curr_))[:, 0]
        return self

    # ESN 모델 통과한 인풋을 머신러닝 모델에 학습
    def fit(self, X, y=None):
        """Initialize the network

        This is more compatibility step, as no learning takes place in the
        reservoir.

        Parameters
        ----------
        X : array-like shape, (n_samples, n_features)
            The data to be transformed.

        Returns
        -------
        self : returns an instance of self.
        """
        self = self._fit_transform(X)
        return self

    # ESN 모델 학습 (가중치 학습)
    def fit_transform(self, X, y=None):
        """Generate echoes from the reservoir.

        Parameters
        ----------
        X : array-like of shape [n_samples, n_features]
            training set.

        Returns
        -------
        readout : array, shape (n_samples, n_readout)
            Reservoir activation generated by the readout neurons
        """
        self = self._fit_transform(X)
        return self.components_[self.readout_idx_, self.discard_steps:].T

    # 학습시킨 모델 사용(사전학습된 가중치 받아서 가중치 학습 X)
    def transform(self, X):
        """Generate echoes from the reservoir

        Parameters
        ----------
        X : array-like shape, (n_samples, n_features)
            The data to be transformed.

        Returns
        -------
        readout : array, shape (n_samples, n_readout)
            Reservoir activation generated by the readout neurons
        """
        X = check_array(X, ensure_2d=True)
        n_samples, n_features = X.shape

        if self.weights_ is None:
            self.weights_ = self.random_state.rand(self.n_components,
                                                   self.n_components) - 0.5
            # spectral_radius = np.max(np.abs(la.eig(self.weights_)[0]))
            ############ spectral_radius 수정!
            spectral_radius = 0.1
            self.weights_ *= self.weight_scaling / spectral_radius

        if self.input_weights_ is None:
            self.input_weights_ = self.random_state.rand(self.n_components,
                                                         1 + n_features) - 0.5
        if self.readout_idx_ is None:
            self.readout_idx_ = self.random_state.permutation(
                arange(1 + n_features,
                       1 + n_features + self.n_components))[:self.n_readout]
        self.components_ = zeros(shape=(1 + n_features + self.n_components,
                                        n_samples))

        curr_ = zeros(shape=(self.n_components, 1))
        U = concatenate((ones(shape=(n_samples, 1)), X), axis=1)
        for t in range(n_samples):
            u = array(U[t, :], ndmin=2).T
            curr_ = (1 - self.damping) * curr_ + self.damping * tanh(
                self.input_weights_.dot(u) + self.weights_.dot(curr_))
            self.components_[:, t] = vstack((u, curr_))[:, 0]

        return self.components_[self.readout_idx_, self.discard_steps:].T